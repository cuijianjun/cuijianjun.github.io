
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>1000 words a Day</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Coldfont">
    

    
    <meta name="description" content="学习总结 思考感悟 知识管理">
<meta property="og:type" content="website">
<meta property="og:title" content="1000 words a Day">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="1000 words a Day">
<meta property="og:description" content="学习总结 思考感悟 知识管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="1000 words a Day">
<meta name="twitter:description" content="学习总结 思考感悟 知识管理">

    
    <link rel="alternative" href="/atom.xml" title="1000 words a Day" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="1000 words a Day" title="1000 words a Day"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="1000 words a Day">1000 words a Day</a></h1>
				<h2 class="blog-motto">Writing 1000 Words a Day Changes My Life</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/04/面向对象/作用域预解析测试题/" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2016-11-04T13:13:46.226Z" itemprop="datePublished"> 发表于 2016-11-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>考题</title>
</head>
<body>
    <script>
         /*// 考题一，变量声明提升及没有块级作用域：
         console.log(a);
         if (false) {
            var a = 10;
         }
         console.log(a);


        // 考题二，考变量提升和没有块级作用域：
        console.log(a);
        if ('a' in window) {
            var a = 10;
        }
        console.log(a);


        // 考题三，考函数作用域：
        if ('a' in window) {
            (function(){
                var a = 10;
            }());
        }
        console.log(a);


         // 考题四，考函数作用域：
         var val = 321;
         function test() {
            if(true) {
                var val = 123;
            }
         }
         test();
         console.log(val);


        // 考题五，考函数作用域：
        (function fn() {
            function fn1 () {
                var a = 1;
            }
            (function fn2 () {
                fn1()
                console.log(a);
            })();
        })();*/

      /*  // 考题六，考词法作用域：
        var val = 1;
        function add1() {
            console.log(val + 1); //2

            /!*
            * 预解析：
            *
            * 正式：
            * 打印val + 1,其中val是变量需要查找该变量的值。
            * *!/
        }
        (function () {
            var val = 10;
            add1();

            /!*
            *  预解析：
            *  var val；
            *
            *  正式：
            *  val = 10;
            *  add1();
            * *!/
        }());*/

         /*
         * 预解析：
         * var val;
         * add1函数声明;
         *
         * 正式：
         * var = 1;
         * 自调函数执行；
         * */

        // 考题七，综合性考题。
       /* var a = 20;
        (function fn() {
            if (false) { var a = 10 }
            (function fn2 () {
                console.log(a);  // undefined

                /!*
                * 预解析：
                *
                * 正式：
                * 打印a
                * *!/
            })();

            /!*
            * 预解析：
            * var a;
            *
            * 正式：
            * if判断;
            * fn2自调执行；
            * *!/
        })();*/

         /*
         * 预解析：
         * var a;
         *
         * 正式：
         * a = 20;
         * 自调函数执行；
         * */


       /* // 考题八，函数内预解析。
        function fn(a) {
            console.log(a);  // undefined  200
            var a = 2;
            console.log(a);  // 2   2

            /!*
            * // 先给形参赋值
            * var a = undefined;
            *
            * 预解析：
            * var a;  // 变量重名，忽略
            *
            * 正式：
            * 打印a;
            * a = 2;
            * 打印a;
            * *!/

            /!*
            * // 先给形参赋值
            * var a = 200;
            *
            * 预解析：
            * var a;  // 变量重名，忽略
            *
            * 正式：
            * 打印a;
            * a = 2;
            * 打印a;
            * *!/
        }
        fn();
        fn(200);*/

         /*
         * 预解析：
         * fn函数声明;
         *
         * 正式：
         * fn();
         * fn(200);
         * */


        /*// 考题九，考变量查找规则。
        var a = 1;
        function fn(a) {
            console.log(a);  // undefined
            a = 2;
            console.log(a);  // 2

            /!*
            * var a = undefined;
            *
            * 预解析：
            *
            * 正式：
            * 打印a;
            * a = 2;
            * 打印a;
            * *!/
        }
        fn();
        console.log(a);  // 1*/

         /*
         *  预解析：
         *  var a;
         *  fn函数声明；
         *
         *  正式：
         *  a = 1;
         *  fn();
         *  打印a;
         * */

       /* // 考题十，词法作用域
        var a = 100;
        function fn() {
            console.log(a);  // 100

            /!*
            * 预解析：
            *
            * 正式：
            * 打印a；
            * *!/
        }
        function fn2() {
            var a = 1;
            fn();
            function fn3 () {
                var type = 'fn';
                console.log(a);  // 1

                /!*
                * 预解析：
                * var type；
                *
                * 正式：
                * type = 'fn';
                * 打印a;
                * *!/
            }
            fn3();

            /!*
            * 预解析：
            * var a；
            * fn3 函数声明；
            *
            * 正式：
            * a = 1;
            * fn();
            * fn3();
            * *!/
        }
        fn2();*/

         /*
         * 预解析：
         *  var a ；
         *  fn 函数声明;
         *  fn2 函数声明;
         *
         * 正式：
         * a = 100;
         * fn2执行；
         * */

        /* // 考题十一
         console.log(a);  // fn2函数
         var a = 1;
         console.log(a);  // 1
         function a() { console.log('fn1') }
         console.log(a);  // 1
         var a = 3;
         console.log(a);  // 3
         function a() { console.log('fn2') }
         console.log(a);  // 3
         var a = function () { console.log('fn3') };
         console.log(a);  // fn3函数

         /!*
         * 预解析：
         * var a；
         * 声明打印fn1的a函数，函数重名，保留当前函数；
         * var a，变量重名，忽略
         * 声明打印fn2的a函数，函数重名，保留当前函数；
         * var a，变量重名，忽略
         *
         * 正式：
         * 打印a；
         * a = 1;
         * 打印a；
         * 打印a；
         * a = 3;
         * 打印a；
         * 打印a；
         * a = 打印fn3的函数;
         * 打印a;
         * *!/*/

         /*// 考题十二
         var a = 1;
         function fn() {
             console.log(a);  // 1
             a = 2;
             console.log(a);  // 2

             /!*
             * 预解析：
             *
             * 正式：
             * 打印a;
             * a = 2;  // 修改的是全局下的a
             * 打印a;
             * *!/
         }
         fn();
         console.log(a);  // 2

         /!*
         * 预解析：
         * var a；
         * fn 函数声明;
         *
         * 正式：
         * a = 1;
         * fn();
         * 打印a;
         * *!/*/


         // 考题十三
         var a = 1;
         function fn(a) {
             console.log(a); // 函数
             var a = 2;
             function a() {}
             console.log(a);  // 2

             /*
             * 形参赋值：
             * var a  = 1;
             *
             * 预解析：
             * var a，重名，忽略；
             * a函数声明，保留当前函数；
             *
             * 正式：
             * 打印a;
             * a = 2;
             * 打印2；
             * */
         }
         fn(a);

         /*
         * 预解析：
         * var a；
         * fn函数声明；
         *
         * 正式：
         * a = 1;
         * fn(a);
         * */

          /*
         // 考题十四，函数写在代码块中的预解析处理
         console.log(f);
         if (true) {
             function f() {
                 console.log(1);
             }
         }else {
             function f() {
                 console.log(2);
             }
         }
         console.log(f);*/
    </script>
</body>
</html>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/04/hello-world/" title="Hello World" itemprop="url">Hello World</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2016-11-04T11:57:39.425Z" itemprop="datePublished"> 发表于 2016-11-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/26/面向对象参考/repaty/" title="重点复习" itemprop="url">重点复习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2016-10-26T09:06:32.000Z" itemprop="datePublished"> 发表于 2016-10-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="重点复习"><a href="#重点复习" class="headerlink" title="重点复习"></a>重点复习</h1><h3 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h3><ul>
<li>面向对象就是利用对象解决问题。</li>
<li>面向对象讲究的是，凡事不用自己亲力亲为。</li>
<li>面向对象离不开面向过程，相当于是对面向过程的封装。</li>
<li>面向对象一般应用与大型软件开发，使用了面向对象开发的大型软件就像是使用Xmind进行组织一样。</li>
</ul>
<h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><ul>
<li>就是对创建对象的过程进行了封装。</li>
<li>如果一个函数调用后，返回值是一个对象，那么就可以认为它是一个工厂函数。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>如果一个用来配合new关键字创建对象，那么就可以称呼这个函数为构造函数。</li>
</ul>
<h3 id="构造函数与普通函数的关系"><a href="#构造函数与普通函数的关系" class="headerlink" title="构造函数与普通函数的关系"></a>构造函数与普通函数的关系</h3><ul>
<li>构造函数与普通函数无异，本身就是一个东西。</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>就是对一些具有相同特征与特性的对象的抽象描述。</li>
<li>在ES6之前，可以把构造函数看作是类。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>通过构造函数创建出来的对象就叫实例。</li>
<li>注：在口头描述上，实例指的是直系后代（在编程语言中，实例也指子孙后代）</li>
</ul>
<h5 id="实例的类型"><a href="#实例的类型" class="headerlink" title="实例的类型"></a>实例的类型</h5><ul>
<li>实例的类型就是构造函数的名字。</li>
</ul>
<h3 id="原型-amp-原型的作用"><a href="#原型-amp-原型的作用" class="headerlink" title="原型&amp;原型的作用"></a>原型&amp;原型的作用</h3><ul>
<li>原型是js提供的一个实现继承的机制。</li>
<li>原型就是为了让实例共享一些属性与方法，达到节省内存以及复用代码的目的。</li>
</ul>
<h5 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h5><ul>
<li>所有的函数默认都含有这个属性</li>
<li>通过函数new出来的实例，都会继承这个属性所指向的对象</li>
</ul>
<h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h5><ul>
<li>所有的对象都含有这个属性</li>
<li>访问一个对象的属性时，如果对象自身没有，就会到<strong>proto</strong>指向的对象中去查找。</li>
</ul>
<h5 id="new构造函数自动执行的4个步骤"><a href="#new构造函数自动执行的4个步骤" class="headerlink" title="new构造函数自动执行的4个步骤"></a>new构造函数自动执行的4个步骤</h5><ul>
<li>new会自动创建一个新对象(本质上就是开辟一块内存空间)</li>
<li>给新对象添加一个<strong>proto</strong>属性，该属性的值为(！当前！)构造函数prototype属性的值。</li>
<li>利用新对象调用构造函数(那么构造函数内的this就指向了新对象)</li>
<li>返回新对象的地址</li>
</ul>
<h3 id="属性查找规则"><a href="#属性查找规则" class="headerlink" title="属性查找规则"></a>属性查找规则</h3><ul>
<li>先找自身，自身没有，顺着<strong>proto</strong>属性查找指定的对象；</li>
<li>这个对象没有，继续顺着<strong>proto</strong>查找；</li>
<li>直到终点。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/19/canvas/canvas01/" title="1canvas基本语法" itemprop="url">1canvas基本语法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2015-01-19T12:37:51.000Z" itemprop="datePublished"> 发表于 2015-01-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-1canvas基本语法"><a href="#1-1canvas基本语法" class="headerlink" title="1.1canvas基本语法"></a>1.1canvas基本语法</h2><h4 id="1-1-1-基本操作"><a href="#1-1-1-基本操作" class="headerlink" title="1.1.1 基本操作"></a>1.1.1 基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var     cvs = document.getElementById(&apos;cvs&apos;);//获取画布</div><div class="line">        var ctx = cvs.getContext(&apos;2d&apos;);//获取画笔</div></pre></td></tr></table></figure>
<p>####1.1.2 设置画布大小</p>
<blockquote>
<p>通过行内或者html，不能通过css去设置，会导致变形</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;cvs&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure>
<p>####1.1.3 非零环绕原则</p>
<blockquote>
<p>原理：随便找一块封闭的区域，然后在区域随便找一点，向外发一条射线， 然后会继续计数判断，初始值为0， 如果射线遇到边，这条边相当于点是逆时针，那么-1，顺时针+1，最终结果非0，那么就认为这块区域是被环绕起来的。</p>
</blockquote>
<p>####1.1.4 基本绘图命令</p>
<ul>
<li>设置开始绘图的位置: <code>ctx.moveTo( x, y )</code>.</li>
<li>设置直线到的位置: <code>ctx.lineTo( x, y )</code>.</li>
<li>描边绘制: <code>ctx.stroke()</code>.</li>
<li>设置填充颜色<code>ctx.fillStyle = &#39;yellow&#39;</code>;</li>
<li>填充绘制: <code>ctx.fill()</code>.//根据路径进行填充</li>
<li>闭合路径: <code>ctx.closePath()</code>.</li>
<li>用来画矩形路径的: <code>ctx.rect( x, y, w, h )</code>.</li>
<li>用来绘制描边矩形，不会产生任何路径: <code>ctx.strokeRect( x, y, w, h )</code>.</li>
<li>用来绘制填充矩形，不会产生任何路径: <code>ctx.fillRect( x, y, w, h )</code>.</li>
<li>清除矩形区域<code>ctx.clearRect</code></li>
<li>设置描边色: <code>ctx.strokeStyle</code> = <code>&quot;颜色单词、rgb、rgba、css支持的方式这里都支持&quot;</code></li>
<li>清理之前的路径：<code>ctx.beginPath()</code>; 为了防止重绘之前的路径，先把他们清除掉</li>
<li>当前路径的结束点和起点连一条路径 <code>ctx.closePath()</code>;  </li>
<li><code>ctx.lineWidth</code> 设置线宽.</li>
<li><code>ctx.lineCap</code> 设置线末端类型.<ul>
<li>设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’.</li>
<li>‘butt’ 表示两端使用方形结束.</li>
<li>‘round’ 表示两端使用圆角结束.</li>
<li>‘square’ 表示突出的圆角结束.</li>
</ul>
</li>
<li><code>ctx.lineJoin</code> 设置相交线的拐点.<ul>
<li>设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认)</li>
<li>‘round’ 使用圆角连接.</li>
<li>‘bevel’ 使用平切连接.</li>
<li>‘miter’ 使用直角转.</li>
</ul>
</li>
<li>如果线帽与交点样式不一致，优先按照交点样式处理。</li>
<li><code>ctx.getLineDash()</code> 获得线段样式数组.</li>
<li><code>ctx.setLineDash()</code> 设置线段样式.</li>
<li><code>ctx.lineDashOffset</code> 绘制线段偏移量.<blockquote>
<p><code>lineDashOffset</code> 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移.<br><code>getLineDash()</code> 与 <code>setLineDash()</code> 方法使用数组描述实线与虚线的长度.</p>
</blockquote>
</li>
</ul>
<p>####1.1.5 基本例子</p>
<blockquote>
<p>等腰三角形</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var cvs = document.getElementById(&apos;cvs&apos;);</div><div class="line">    var ctx = cvs.getContext(&apos;2d&apos;);</div><div class="line">    ctx.moveTo(100, 100);</div><div class="line">    ctx.lineTo(100 + 50 / 2, 100 + 50);</div><div class="line">    ctx.lineTo(100 - 50 / 2, 100 + 50);</div><div class="line">    ctx.lineTo(100, 100);</div><div class="line">    ctx.strokeStyle = &apos;skyblue&apos;;</div><div class="line">    ctx.stroke();</div></pre></td></tr></table></figure>
<blockquote>
<p>封装等腰三角形（函数）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function strokeSJX( x, y, w, h, style ) &#123;</div><div class="line">        ctx.beginPath();   // 为了防止重绘之前的路径，先把他们清除掉</div><div class="line">        ctx.moveTo(x, y);</div><div class="line">        ctx.lineTo(x + w / 2, y + h);</div><div class="line">        ctx.lineTo(x - w / 2, y + h);</div><div class="line">        ctx.lineTo(x, y);</div><div class="line">        ctx.strokeStyle = style;</div><div class="line">        ctx.stroke();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    strokeSJX( 100, 100, 100, 50, &apos;red&apos; );</div></pre></td></tr></table></figure>
<blockquote>
<p>封装渐变矩形</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function JX( x, y, w, h, direction ) &#123;</div><div class="line">    var i = 0, lineNum;</div><div class="line">    // 如果是横方式，线的总数为宽度；</div><div class="line">    // 如果是竖方式，线的总数为高度。</div><div class="line">    lineNum = direction === &apos;h&apos;? w : h;</div><div class="line">    // 分别画每一条不同颜色的线，共同组成一个渐变矩形</div><div class="line">    for ( ; i &lt; lineNum; i++ ) &#123;</div><div class="line">        ctx.beginPath();</div><div class="line">        if ( direction === &apos;h&apos; ) &#123;</div><div class="line">            ctx.moveTo( x + i, y);</div><div class="line">            ctx.lineTo( x + i, y + h);</div><div class="line">        &#125;else &#123;</div><div class="line">            ctx.moveTo( x, y + i);</div><div class="line">            ctx.lineTo( x + w, y + i);</div><div class="line">        &#125;</div><div class="line">        ctx.strokeStyle = &apos;rgb(&apos; + Math.ceil(255 / lineNum * i) + &apos;, 0, 0)&apos;;</div><div class="line">        ctx.stroke();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 测试</div><div class="line">JX( 10, 10, 100, 100, &apos;h&apos; );</div><div class="line">JX( 210, 10, 80, 100 );</div></pre></td></tr></table></figure>
<blockquote>
<p>网格</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">* 画网格，</div><div class="line">* 先画N多横线，</div><div class="line">* 再画N多竖线。</div><div class="line">// 画宽为10，高为10的网格</div><div class="line">var w = 10, h = 10,</div><div class="line">    cvsW = cvs.width,</div><div class="line">    cvsH = cvs.height;</div><div class="line">// 先画横线</div><div class="line">for ( var i = 1, num = cvsH / h; i &lt; num; i++ ) &#123;</div><div class="line">    ctx.moveTo( 0, h * i );</div><div class="line">    ctx.lineTo( cvsW, h * i );</div><div class="line">&#125;</div><div class="line">// 再画竖线</div><div class="line">for ( var i = 1, num = cvsW / w; i &lt; num; i++ ) &#123;</div><div class="line">    ctx.moveTo( w * i, 0 );</div><div class="line">    ctx.lineTo( w * i, cvsH );</div><div class="line">&#125;</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<blockquote>
<p>在自定义的坐标里画点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">// 定义坐标轴距离画布的边距</div><div class="line">var paddingLeft = 10;</div><div class="line">var paddingTop = 10;</div><div class="line">var paddingRight = 10;</div><div class="line">var paddingBottom = 10;</div><div class="line">// 箭头的宽高</div><div class="line">var arrow = &#123;</div><div class="line">    w: 10,</div><div class="line">    h: 20</div><div class="line">&#125;;</div><div class="line">// 先画坐标轴中的竖线</div><div class="line">// 竖线的顶点坐标为( paddingLeft, paddingTop );</div><div class="line">// 原点的坐标为( paddingLeft, cvs.height -  paddingBottom );</div><div class="line">// 横线的顶点坐标为( cvs.width - paddingRight, cvs.height -  paddingBottom );</div><div class="line">var s = &#123;</div><div class="line">    x: paddingLeft,</div><div class="line">    y: paddingTop</div><div class="line">&#125;;</div><div class="line">var o = &#123;</div><div class="line">    x: paddingLeft,</div><div class="line">    y: cvs.height -  paddingBottom</div><div class="line">&#125;;</div><div class="line">var h = &#123;</div><div class="line">    x: cvs.width - paddingRight,</div><div class="line">    y: cvs.height -  paddingBottom</div><div class="line">&#125;;</div><div class="line">// 画坐标轴的两条线</div><div class="line">ctx.moveTo( s.x, s.y );</div><div class="line">ctx.lineTo( o.x, o.y );</div><div class="line">ctx.lineTo( h.x, h.y );</div><div class="line">// 先画竖线箭头</div><div class="line">ctx.moveTo( s.x, s.y );</div><div class="line">ctx.lineTo( s.x - arrow.w / 2, s.y + arrow.h );</div><div class="line">ctx.moveTo( s.x, s.y );</div><div class="line">ctx.lineTo( s.x + arrow.w / 2, s.y + arrow.h );</div><div class="line">// 再画横线箭头</div><div class="line">ctx.moveTo( h.x, h.y );</div><div class="line">ctx.lineTo( h.x - arrow.h, h.y - arrow.w / 2 );</div><div class="line">ctx.moveTo( h.x, h.y );</div><div class="line">ctx.lineTo( h.x - arrow.h, h.y + arrow.w / 2 );</div><div class="line">ctx.stroke();</div><div class="line">/*</div><div class="line">* 在10，10位置画一点:</div><div class="line">* 该点坐标的算法：</div><div class="line">* x轴 = 原点的x轴 + 该点和原点的距离</div><div class="line">* y轴 = 原点的y轴 - 该点和原点的距离</div><div class="line">* */</div><div class="line">// ctx.fillRect( o.x + 10, o.y - 10, 1, 1 );</div><div class="line">/*</div><div class="line">* 需求：在自定义的坐标轴中画N多点</div><div class="line">* */</div><div class="line">var points = [ 10, 10, 30, 30, 50, 30, 70, 40, 110, 150 ];</div><div class="line">for ( var i = 0, len = points.length; i &lt; len; i+=2 ) &#123;</div><div class="line">    ctx.fillRect( o.x + points[i], o.y - points[i+1], 3, 3 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>补充上面代码块,在上述的基础上画折线</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath(); // 新开辟路径，现在就没有任何路径，以及路径的起点和结束点了。</div><div class="line">// 再画折线</div><div class="line">for ( var i = 0, len = points.length; i &lt; len; i+=2 ) &#123;</div><div class="line">    ctx.lineTo( o.x + points[i], o.y - points[i+1] );</div><div class="line">&#125;</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<blockquote>
<p>等比例的放大折线图</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">var cvs=document.getElementById(&quot;cvs&quot;)</div><div class="line">    var ctx=cvs.getContext(&quot;2d&quot;);</div><div class="line">    var paddingLeft = 10;</div><div class="line">    var paddingTop = 10;</div><div class="line">    var paddingRight = 10;</div><div class="line">    var paddingBottom = 10;</div><div class="line">        // 箭头的宽高</div><div class="line">    var arrow = &#123;</div><div class="line">        w: 10,</div><div class="line">        h: 20</div><div class="line">    &#125;;</div><div class="line">        // 先画坐标轴中的竖线</div><div class="line">    // 竖线的顶点坐标为( paddingLeft, paddingTop );</div><div class="line">    // 原点的坐标为( paddingLeft, cvs.height -  paddingBottom );</div><div class="line">    // 横线的顶点坐标为( cvs.width - paddingRight, cvs.height -  paddingBottom );</div><div class="line">    var s = &#123;</div><div class="line">        x: paddingLeft,</div><div class="line">        y: paddingTop</div><div class="line">    &#125;;</div><div class="line">    var o = &#123;</div><div class="line">        x: paddingLeft,</div><div class="line">        y: cvs.height -  paddingBottom</div><div class="line">    &#125;;</div><div class="line">    var h = &#123;</div><div class="line">        x: cvs.width - paddingRight,</div><div class="line">        y: cvs.height -  paddingBottom</div><div class="line">    &#125;;</div><div class="line">    ctx.moveTo(s.x, s.y)</div><div class="line">    ctx.lineTo(o.x, o.y)</div><div class="line">    ctx.lineTo(h.x, h.y)</div><div class="line">    //先画竖箭头</div><div class="line">    ctx.moveTo(s.x, s.y);</div><div class="line">    ctx.lineTo(s.x-arrow.w/2, s.y+arrow.h);</div><div class="line">    ctx.moveTo(s.x, s.y);</div><div class="line">    ctx.lineTo(s.x+arrow.w/2, s.y+arrow.h);</div><div class="line">    //横箭头</div><div class="line">    ctx.moveTo(h.x, h.y);</div><div class="line">    ctx.lineTo(h.x-arrow.h, h.y-arrow.w/2);</div><div class="line">    ctx.moveTo(h.x, h.y);</div><div class="line">    ctx.lineTo(h.x-arrow.h, h.y+arrow.w/2);</div><div class="line">    ctx.stroke();</div><div class="line">    //折线点的坐标</div><div class="line">    var points = [ 10, 10, 30, 30, 50, 30, 70, 40, 110, 150 ];</div><div class="line">    //求自定义的画布的最大显示面积</div><div class="line">    var maxKD = &#123;</div><div class="line">        x: cvs.width - paddingLeft - paddingRight - arrow.h,</div><div class="line">        y: cvs.height - paddingTop - paddingBottom - arrow.h</div><div class="line">    &#125;;</div><div class="line">    //对折线点进行区别，x,y轴的数据都提出来，然后放大比例进行处理</div><div class="line">    var pointXs=[];</div><div class="line">    var pointYs=[];</div><div class="line">    for(var i= 0,len=points.length;i&lt;len;i++)&#123;</div><div class="line">        if(i%2===0)&#123;</div><div class="line">            pointXs.push(points[i])</div><div class="line">        &#125;else&#123;</div><div class="line">            pointYs.push(points[i])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">//求折线点的最大x,y值</div><div class="line">    var pointsMaxX = Math.max.apply(null, pointXs);</div><div class="line">    var pointsMaxY = Math.max.apply(null, pointYs);</div><div class="line">//    求出比例</div><div class="line">    var ratioX = maxKD.x / pointsMaxX;</div><div class="line">    var ratioY = maxKD.y / pointsMaxY;</div><div class="line">//    画折线的点</div><div class="line">    for(var i= 0,len=points.length;i&lt;len;i+=2)&#123;</div><div class="line">        ctx.fillRect(o.x+points[i]*ratioX, o.y-points[i+1]*ratioY,4,4)</div><div class="line">    &#125;</div><div class="line">    ctx.beginPath();</div><div class="line">    for(var i= 0,len=points.length;i&lt;len;i+=2)&#123;</div><div class="line">        ctx.lineTo(o.x+points[i]*ratioX+2, o.y-points[i+1]*ratioY+2)</div><div class="line">    &#125;</div><div class="line">    ctx.stroke();</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/canvas/">canvas</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/hexo/">hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/15/面向对象/day04/" title="面向对象第四天" itemprop="url">面向对象第四天</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2015-01-15T12:37:51.000Z" itemprop="datePublished"> 发表于 2015-01-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4><ul>
<li>封装<blockquote>
<p>把一堆相关性的变量和函数组织到一起</p>
</blockquote>
</li>
<li>继承<blockquote>
<p>原型</p>
</blockquote>
</li>
<li>多态<blockquote>
<p>对象的动态变化</p>
</blockquote>
</li>
</ul>
<p>####for in</p>
<ul>
<li>for in用来遍历一个对象可枚举的属性</li>
<li>需要注意：该对象继承的属性也能够被遍历出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object.prototype.it = &apos;科技&apos;;</div><div class="line">       var obj = &#123; val: 1 &#125;;</div><div class="line"></div><div class="line">       // 打印 val 和 it</div><div class="line">       for ( var key in obj ) &#123;</div><div class="line">           console.log(key);</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>####静态成员与实例成员</p>
<ul>
<li><p>静态成员（类成员）:添加给类（构造函数）自己的属性和方法</p>
<ul>
<li>什么情况下会用到静态成员：</li>
</ul>
<ol>
<li>如果一些属性和类的关联性比较大，那么可以考虑作为静态属性存在</li>
<li>如果一些方法具有通用性，那么可以考虑将其作为静态方法存在<blockquote>
<p>Person.MAX_AGE = 200;</p>
</blockquote>
</li>
</ol>
</li>
<li>实例成员:添加给实例的属性和方法</li>
</ul>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Person( name, age ) &#123;</div><div class="line">            // 这是添加给将来的实例的，所以这是实例成员</div><div class="line">            this.name = name;</div><div class="line">            this.age = age    </div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">添加到原型中的属性与方法，本意是让实例使用的，所以也可以理解为是实例成员</div><div class="line">        Person.prototype.run = function () &#123;</div><div class="line">            console.log(&apos;run&apos;);</div><div class="line">        &#125;;</div><div class="line">```        </div><div class="line"></div><div class="line">#### Object 原型上的几种方法</div><div class="line"></div><div class="line">- hasOwnProperty</div><div class="line"></div><div class="line">&gt; 作用:判断一个对象是否含有（自己）的某个属性</div><div class="line">语法：对象.hasOwnProperty(要判断的属性)</div><div class="line">返回值：boolean</div></pre></td></tr></table></figure>
<p>实例代码<br>    var obj = { a: 1 };<br>            console.log(obj.hasOwnProperty(‘a’));  // true<br>            console.log(obj.hasOwnProperty(‘b’));  // false<br>            console.log(obj.hasOwnProperty(‘constructor’));  // false<br>            console.log(Object.prototype.hasOwnProperty(‘hasOwnProperty’));  // true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- propertyIsEnumerable</div><div class="line"></div><div class="line">&gt; 作用:判断一个对象是否（自己）含有某种属性，并且判断该属性是否可枚举；这个属性是双重判断，通常称这个方法为hasOwnProperty的加强版</div><div class="line">语法:对象.propertyIsEnumerable(要判断的属性名);</div><div class="line">返回值：boolean</div></pre></td></tr></table></figure></p>
<p><code><br>var obj2 = { a: 1 };<br>        console.log(obj2.propertyIsEnumerable(‘a’));  // true<br>        console.log(obj2.propertyIsEnumerable(‘b’)); // false<br>        console.log(obj2.propertyIsEnumerable(‘constructor’));  // false<br>        console.log(Object.prototype.propertyIsEnumerable(‘hasOwnProperty’));  // false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- isprototypeOf</div><div class="line"></div><div class="line">&gt; 作用：判断一个对象是不是另一个对象的原型对象</div><div class="line">语法:被判断的对象.isprototypeOf(对象)</div><div class="line">返回值:boolean</div></pre></td></tr></table></figure></code></p>
<p><code><br>console.log( Object.prototype.isPrototypeOf( obj2 ) );  // true<br>        console.log( Object.prototype.isPrototypeOf( Object ) );  // true<br>        console.log( Function.prototype.isPrototypeOf( Function ) ); // true<br>        console.log( Function.prototype.isPrototypeOf( Math ) );  // false，<br>        因为Math只继承Object.prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- toString</div><div class="line"></div><div class="line">&gt;  作用:根据方法执行时内部的this指向，返回一个类似这样的字符串&apos;[Object this对象的类型名称]&apos;</div><div class="line">通过这个字符串可以得知内置对象的类型</div><div class="line"> 使用技巧：为了让内部执行时，内部的this指向Math，所以把这个方法添加到Math自身，</div><div class="line"> 然后通过Math调用，这样toString执行时，内部this指向Math</div></pre></td></tr></table></figure></code></p>
<p><code><br>Math.toStr = Object.prototype.toString;<br>        console.log(Math.toStr());<br>        Date.toStr = Object.prototype.toString;<br>        console.log(Date.toStr());<br> 另一种方法:this指向<br>        console.log(Object.prototype.toString.call(Math));<br>        console.log(Object.prototype.toString.call(Function));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#####自定义构造函数创建的对象统一返回&apos;[object Object]&apos;</div><div class="line"></div><div class="line">####函数的几种属性</div><div class="line"></div><div class="line">1. arguments代表实参的伪数组对象，</div><div class="line">&gt; arguments 有一个callee属性，该属性返回被调用的函数。</div><div class="line">说白一点，callee就是返回函数自己。</div><div class="line">2. caller 返回调用该函数的函数</div><div class="line">3. length 形参的个数</div><div class="line"></div><div class="line">- 函数length属性的作用-------------------判断函数的形参和调用时传入的实参数目是否一致</div></pre></td></tr></table></figure></code></p>
<p>function add(a, b) {<br>            if ( arguments.length !== add.length ) {<br>                throw ‘参数个数不符！’;<br>            }<br>            console.log(a + b);<br>        }</p>
<pre><code>add(10,20);
add(1);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">4. name 函数的名字</div></pre></td></tr></table></figure>
<p><code><br>function fn(a, b, c) {<br>            console.log(arguments);  // 这是推荐的使用方式<br>            console.log(fn.arguments);  // 这种方式已经被废除了<br>        }<br>        console.dir(fn);<br>        console.log(fn.name);<br>        console.log(fn.length);<br>        fn(1,2);</code></p>
<pre><code>&lt;返回调用函数&gt;
 function f1() {
            console.log(f1.caller);
        }

        !function f2() {
            f1();
        }();

        f1();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####in 运算符-----判断后面的对象是否有前面的属性或者方法</div><div class="line"></div><div class="line">`</div></pre></td></tr></table></figure>
<p>var obj = { aa: 11 };<br>        console.log( ‘aa’ in obj );<br>        console.log( ‘bb’ in obj );<br>        console.log( ‘hasOwnProperty’ in obj );<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####delete 运算符</div><div class="line"></div><div class="line">- 作用：删除对象的属性和方法</div><div class="line">- 语法: delete 对象.属性名</div></pre></td></tr></table></figure></p>
<p>var obj = { aa : 10, bb : 230, 1: 100, 2: 200 };<br>        delete obj.bb;<br>        delete obj[2];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####Function </div><div class="line">- Function创建函数的语法:new Function( arg_name1, arg_name2, arg_name3, functionBody )</div><div class="line">前面可以定义任意数量的形参，最后一个参数代表函数的代码体。注意：这些参数必须是字符串的形式</div><div class="line">- 返回值：一个新创建的函数实例。</div></pre></td></tr></table></figure></p>
<p><code><br> function add(a, b) {<br>            console.log(a + b);<br>        }</code></p>
<pre><code>var addObj = new Function(&apos;a&apos;, &apos;b&apos;, &apos;console.log(a + b);&apos;);
addObj(10, 60);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">**如果使用Function创建函数，很繁琐，一般不会采纳。</div><div class="line">但是这种方式有一个亮点，就是会把字符串当做代码执行。**</div><div class="line"></div><div class="line">####方法</div><div class="line"></div><div class="line">1. eval可以直接把字符串当做代码执行</div><div class="line"> - 语法：eval(字符串代码)   example: ``eval(&apos;console.log(123223)&apos;)``</div><div class="line"></div><div class="line">2. JSON数据格式 ==&gt;   &apos;&#123; &quot;name&quot;: &quot;李四&quot; &#125;&apos;</div><div class="line"></div><div class="line">- JSON.parse:用来把Json数据转化为js对象</div><div class="line">- JSON.stringify:用来把js对象转化为Json数据</div><div class="line">- 在ie8之前，可以用过eval或者Function解析JSON数据</div><div class="line">    * var JSONString = &apos;&#123; &quot;name&quot;: &quot;李四&quot; &#125;&apos;;</div><div class="line">   console.log(eval(&apos;(&apos;+JSONString+&apos;)&apos;));</div><div class="line">    * 返回的函数的代码体：return &#123; &quot;name&quot;: &quot;李四&quot; &#125;</div><div class="line">   console.log(Function(&apos;return &apos; + JSONString)()//自调);</div><div class="line">        </div><div class="line">--- </div><div class="line">###注意事项</div><div class="line">1. 很多地方认为构造函数默认的显式原型对象的类型，是构造函数的名字。</div><div class="line">即 Person.prototype 是 Person 类型的对象</div><div class="line">------------------</div><div class="line"></div><div class="line"></div><div class="line">##函数作用域</div><div class="line"></div><div class="line">###预解析</div><div class="line"></div><div class="line">&gt;1. 在代码整体执行前，会先进行解析一部分，解析后代码会从上到下依次整体执行，但是预解析过的代</div><div class="line">码不会重新执行。</div><div class="line">2. js预解析会把声明的部分提前执行</div><div class="line"></div><div class="line">- 声明的代码部分</div><div class="line">    + 变量声明 通过var关键字定义的变量</div><div class="line">    + 函数声明 通过function关键字声明的变量</div></pre></td></tr></table></figure>
<p><code></code></p>
<pre><code>// 其中var a是声明部分。
var a = 1;
// 这里的语句整体都是声明部分。
var b, c, d;
// 其中var e, f, p是声明部分。
var e, f = j = 2, p;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###函数</div><div class="line"></div><div class="line">####函数表达式</div><div class="line"></div><div class="line">&gt;   不是以function关键字定义的函数;或者函数嵌套在非函数的代码块中</div><div class="line"></div><div class="line">- 特征</div><div class="line"></div><div class="line">1. 不会被预解析</div><div class="line">2. 函数名字可有可无</div><div class="line">3. 函数名字只能在函数内部使用</div></pre></td></tr></table></figure>
<pre><code>// 这是函数表达式
    var f = function () {};
    {
        // 在非函数的代码块中定义的函数是函数表达式
        function f() {
        }
    }

    // 这是函数表达式
    (function () {})();
    // 这是函数表达式
    !function () {}();
    // 传入的函数是函数表达式
    fn(function () {});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p> /*</p>
<pre><code>* 一个函数声明式的语法，写在非函数的代码块中，理论上这是函数表达式。
* 但是对于这种函数，浏览器会预解析它的名字。
* */
console.log(fn);
{
    // 这是函数表达式
    function fn() {
    }
}
console.log(fn);
/*
* 预解析：
* var fn;
* 预解析之后：
* console.log(fn);
* fn = function fn() {}
* console.log(fn);
* */
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####函数声明式</div><div class="line"></div><div class="line">&gt; 以function关键字开头定义，并且定义在全局,或者直接嵌套在另一个函数里</div><div class="line">特征:</div><div class="line"> 1. 会被预解析</div><div class="line"> 2. 函数必须有名字</div><div class="line"> </div><div class="line">- 函数声明提升的特点:在函数声明的前面，可以调用这个函数 </div><div class="line"></div><div class="line">&gt; fn(); function fn() &#123;console.log(1);&#125;</div><div class="line"></div><div class="line">####预解析的规则</div><div class="line"></div><div class="line">- 预解析如果遇到重复的变量声明，那么忽略</div><div class="line">- 如果遇到重复的函数声明，保留后面的函数</div></pre></td></tr></table></figure>
<p><code><br> fn();<br>        function fn() {<br>            console.log(111);<br>        }<br>        function fn() {<br>            console.log(222);<br>        }<br>        fn();</code></p>
<pre><code>/*
* 预解析：
* 第一个fn函数声明
* 第二个fn函数声明，发现重名，保留后面的函数
*
* 预解析之后：
* fn();
* fn();
* */
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 如果遇到变量与函数重名，留下函数</div><div class="line">#####关于预解析时重名处理的特点：</div><div class="line"></div><div class="line">    * 凡是遇到重名的变量声明，那么忽略；</div><div class="line">    * 凡是遇到重名的函数声明，当前的函数覆盖之前的。</div><div class="line"></div><div class="line">- 函数内部预解析</div></pre></td></tr></table></figure>
<p><code><br> /*</code></p>
<pre><code>* 一个函数声明式的语法，写在非函数的代码块中，理论上这是函数表达式。
* 但是对于这种函数，浏览器会预解析它的名字。
* */
console.log(fn);
{
    // 这是函数表达式
    function fn() {
    }
}
console.log(fn);
/*
* 预解析：
* var fn;
* 预解析之后：
* console.log(fn);
* fn = function fn() {}
* console.log(fn);
* */
</code></pre><p>```</p>
<p>####作用域 变量的有效范围</p>
<ul>
<li>检测一个变量的作用域</li>
</ul>
<blockquote>
<p>在指定的区域内使用这个变量，如果不报错，说明这个变量的作用域包含此区域</p>
</blockquote>
<ul>
<li>函数作用域</li>
</ul>
<blockquote>
<p>只有函数能够划分变量的作用域，这种作用域的规则叫函数作用域</p>
</blockquote>
<ol>
<li><p>函数外面无法访问函数内的变量</p>
</li>
<li><p>代码块外面可以访问里面的变量</p>
</li>
</ol>
<ul>
<li>块级作用域</li>
</ul>
<blockquote>
<p>凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域<br>ES6，对块级作用域做了支持，新增了两种定义变量的方式  <strong>(let , const)</strong></p>
</blockquote>
<ol>
<li><p>{</p>
<pre><code>    let arr = [];
    console.log(arr);
}
//console.log(arr);
</code></pre></li>
<li><p>{</p>
<pre><code>    const obj = {};
    console.log(obj);
}
console.log(obj);
</code></pre></li>
</ol>
<p>####全局变量与局部变量</p>
<blockquote>
<p>全局变量和局部变量就是通过作用域的大小来对变量进行的种类划分。</p>
</blockquote>
<ul>
<li><p>全局变量:在任何地方都可以使用的变量叫做称为全局变量（函数外定义的变量）</p>
</li>
<li><p>局部变量:只有在指定地方可以使用的变量成为局部变量（函数内申明的变量）</p>
</li>
</ul>
<p>####词法作用域(变量查找规则)</p>
<ul>
<li><p>词法作用域(静态作用域)：如果在函数内访问一个变量，优先找局部变量和形参,如果没用找到，<br>去定义该函数的环境中查找，直到全局为止。 </p>
</li>
<li><p>动态作用域：如果在函数内访问一个变量，优先找局部变量和形参,如果没用找到，去调用该函数<br>的环境中查找，直到全局为止。</p>
</li>
</ul>
<p>####块级作用域 函数作用域 词法作用域</p>
<ul>
<li>之间的区别：</li>
</ul>
<ol>
<li>块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域</li>
<li>词法作用域描述的是，变量的查找规则。</li>
</ol>
<ul>
<li>之间的关系：</li>
</ul>
<ol>
<li>块级作用域 包含 函数作用域。</li>
<li>词法作用域 与 块级作用域&amp;函数作用域之间没有任何交集，</li>
</ol>
<ul>
<li>他们从两个角度描述了作用域的规则。<blockquote>
<p>ES6之前js采用的是函数作用域+词法作用域，ES6 js采用的是块级作用域+词法作用域 。</p>
</blockquote>
</li>
</ul>
<hr>
<p>注意事项</p>
<ol>
<li>函数执行时形参赋值的顺序（在预解析之前）</li>
</ol>
<hr>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/面向对象/">面向对象</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/hexo/">hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/14/面向对象/day05/" title="面向对象第五天" itemprop="url">面向对象第五天</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2015-01-14T12:37:51.000Z" itemprop="datePublished"> 发表于 2015-01-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><blockquote>
<ul>
<li>变量所有的有效区块(运行环境)，统称作用域链</li>
<li>环境：一个东西所依赖东西，就可以认为是他的环境</li>
<li>执行环境：代码执行时所依赖的环境，函数被调用一次，就会产生一个执行环境</li>
</ul>
</blockquote>
<p>####广义闭包</p>
<ul>
<li>可以访问非自身变量的函数，从这个角度来讲，所有的函数都是闭包(1)</li>
<li>使用了非自身变量的函数，就是闭包(2)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var globalA = 10;</div><div class="line">        // 这个函数，可以使用非自身的变量，那么这是一个闭包。</div><div class="line">        function fn() &#123;</div><div class="line">            console.log(globalA);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>####狭义闭包</p>
<ul>
<li>可以访问非自身局部变量的函数，从这种角度来讲，函数内的函数才是闭包(1)</li>
<li>使用了非自身局部变量的函数(2)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var globalA = 10;</div><div class="line">        // 这个函数，只能使用全局变量和自身的局部变量，所以不是闭包。</div><div class="line">        function fn() &#123;</div><div class="line">            console.log(globalA);</div><div class="line">        &#125;</div><div class="line">        /*------------------------------------------------------*/</div><div class="line">        (function () &#123;</div><div class="line">            var val = 10;</div><div class="line">            // 这个函数可以使用自调函数中的局部变量，所以是闭包</div><div class="line">            function f() &#123;</div><div class="line">                console.log(val);</div><div class="line">            &#125;</div><div class="line">        &#125;());</div></pre></td></tr></table></figure>
<p>####闭包的特点</p>
<ul>
<li>可以在任何地方操作一个局部变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function fn() &#123;</div><div class="line">           var a = 1;</div><div class="line">           return function () &#123;</div><div class="line">               console.log(a++);</div><div class="line">           &#125;;</div><div class="line">       &#125;</div><div class="line">       var f = fn();</div><div class="line">       f();</div><div class="line">       f();</div></pre></td></tr></table></figure>
<p>####生命周期</p>
<blockquote>
<p>一个生物从出生开始到死亡结束，中间存活的过程叫生命周期</p>
</blockquote>
<p>####变量的生命周期</p>
<blockquote>
<p>一个变量从定义开始，到释放结束，中间存活的过程就叫变量的生命周期</p>
</blockquote>
<p>####全局变量的生命周期</p>
<blockquote>
<p>从定义开始，到页面卸载结束，就是全局变量的生命周期</p>
</blockquote>
<p>####局部变量的生命周期</p>
<blockquote>
<p>一般情况下，从变量定义开始，到函数执行完毕结束，就是局部变量的生命周期</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function fn() &#123;</div><div class="line">            // 这个变量，从fn调用时定义，到函数执行完毕结束。</div><div class="line">            var val = 10;</div><div class="line">        &#125;</div><div class="line">        fn();</div></pre></td></tr></table></figure>
<ul>
<li>二般情况可以通过闭包实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function fn() &#123;</div><div class="line">            var a = 1;</div><div class="line">            // 当fn执行完毕后，因为匿名函数需要使用局部变量a,</div><div class="line">            // 所以造成a变量没有释放。</div><div class="line">            // 总结：闭包可以延长局部变量的生命周期</div><div class="line">            return function () &#123;</div><div class="line">                console.log(a);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        var f = fn();</div><div class="line">        f();</div><div class="line">        f();</div><div class="line">```   </div><div class="line"> </div><div class="line">&gt;  因为f变量一直存储着一个闭包函数，js解析引擎无法得知将来是否还有调用f函数，所以f函数不会被释</div><div class="line">放，那么对应的a局部变量也不会被释放，这样就会造成内存浪费，如果将来f函数不会再使用了，最好手动</div><div class="line">给f 赋值为 null。</div></pre></td></tr></table></figure>
<p>// 如果想要阻止a的释放，必须要借助闭包<br>        function fn() {<br>            var a = 1;<br>            return function () {<br>                return a;<br>            };<br>        }</p>
<pre><code>var f = fn();
var f2 = fn();

// f调用和f2调用后，得到的a值，是来源与同一个a的。
console.log(f());
console.log(f2());
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####闭包的应用场景</div></pre></td></tr></table></figure>
<p> /*</p>
<pre><code>* 1 操作私有属性(目的，为了防止其他地方对该属性进行随意修改的隐患)
* */

var total = 0;
total+=10;
total++;
console.log(total);

/*-----------------------------------------------*/
function getCounter() {
    var total = 0;
    return function () {
        console.log(total++);
    }
}
var counter = getCounter();
counter();
counter();
* 防止变量被全局污染
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">####编辑一段可以缓存数据的代码</div></pre></td></tr></table></figure>
<p>var cache = {};</p>
<pre><code>// 给缓存中添加数据
function setCache(key, val) {
    cache[key] = val;
}

// 获取缓存中指定的数据
function getCache(key) {
    return cache[key];
}

/*---------------------------------------------------------*/

function getCacheObj() {
    var cache = {};

    // 给缓存中添加数据
    function setCache(key, val) {
        cache[key] = val;
    }

    // 获取缓存中指定的数据
    function getCache(key) {
        return cache[key];
    }

    return {
        setCache: setCache,
        getCache: getCache,
    }
}

var cacheObj = getCacheObj();
cacheObj.setCache(&apos;val&apos;, 888);
console.log(cacheObj.getCache(&apos;val&apos;));
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">####return基本数据类型和对象的区别</div><div class="line"></div><div class="line">1. 基本数据类型</div></pre></td></tr></table></figure>
<p>function fn() {<br>            var a = 1;<br>            return a;<br>        }</p>
<pre><code>/*
 * fn执行结果是返回一个数值，
 * 那么a和a2分别存储返回数值的一个copy版本。
 * */
var a = fn();
var a2 = fn();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 对象</div></pre></td></tr></table></figure>
<p>function fn() {<br>            var obj = {};<br>            return obj;<br>        }</p>
<pre><code>/*
* fn执行结果是返回一个对象的地址，
* 那么o和o2存储是同一个对象的地址。
* */
var o = fn();
var o2 = fn();
</code></pre><p>```</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/面向对象/">面向对象</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/hexo/">hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/14/面向对象/2016.10.12面向对象第七天 补充/" title="面向对象 第七天补充" itemprop="url">面向对象 第七天补充</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2015-01-14T12:37:51.000Z" itemprop="datePublished"> 发表于 2015-01-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一、需求（例题）"><a href="#一、需求（例题）" class="headerlink" title="一、需求（例题）"></a>一、需求（例题）</h2><ul>
<li>如果传入一个基本数据类型，则返回则数据的类型字符串描述，要求全部小写; [toc]</li>
<li>如果传入一个对象类型，则返回则对象的类型字符串描述，要求首字母大写;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function getType(data)&#123;</div><div class="line">  //如果data不等于自己，那data就是NaN</div><div class="line">  //如果data全等于null，那data就是null</div><div class="line">  //使用typeof可以判断string、boolean、number、undefined</div><div class="line">  //最后剩下的对象，统一使用(&#123;&#125;).toString方法获取</div><div class="line">  //NaN</div><div class="line">  if(data!==data)&#123;</div><div class="line">        return &quot;NaN&quot;;</div><div class="line">  &#125;else if(data===null)&#123;</div><div class="line">        return &quot;null&quot;;</div><div class="line">  &#125;else if(typeof data !==&quot;object&quot; &amp;&amp; typeof data !==&quot;function&quot;)&#123;</div><div class="line">         return typeof data;</div><div class="line">  &#125;else&#123;</div><div class="line">        return (&#123;&#125;).toString.call(data).slice(8,-1);  外面的括号为什么存在？</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##二、Function.prototype</p>
<blockquote>
<p>Function.prototype自身是一个函数，并且是唯一一个没有prototype属性的函数。</p>
<p>Function.prototype上定义了一下属性及方法</p>
</blockquote>
<ul>
<li>apply：方法，可以改变函数执行时内部的this的指向</li>
<li>arguement：被废弃了</li>
<li>bind：方法 返回一个函数的copy版本，并且可以指定该函数执行时内部this的指向</li>
<li>call: 方法，可以改变函数的执行时内部this的指向</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/面向对象/">面向对象</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/hexo/">hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/14/面向对象/day03/" title="面向对象第三天" itemprop="url">面向对象第三天</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2015-01-14T12:37:51.000Z" itemprop="datePublished"> 发表于 2015-01-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="面向对象第三天"><a href="#面向对象第三天" class="headerlink" title="面向对象第三天"></a>面向对象第三天</h2><h4 id="构造函数的默认的prototype的继承结构"><a href="#构造函数的默认的prototype的继承结构" class="headerlink" title="构造函数的默认的prototype的继承结构"></a>构造函数的默认的prototype的继承结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line">var xioahong=new Person()</div><div class="line">    原型链</div><div class="line">//xiaohong==&gt;Person.prototype==&gt;Object.prototype==&gt;null</div></pre></td></tr></table></figure>
<ul>
<li><p>{}是new Object的简写形式</p>
<blockquote>
<p> obj==&gt;Object.prototype==&gt;null</p>
</blockquote>
</li>
<li><p>[]是arr的字面量</p>
<blockquote>
<p>arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; null</p>
</blockquote>
</li>
<li><p>Math的继承结构</p>
<blockquote>
<p>Math ==&gt; Object.prototype ==&gt; null</p>
</blockquote>
</li>
<li><p>strObj的继承结构</p>
<blockquote>
<p>strObj ==&gt; String.prototype ==&gt; Object.prototype ==&gt; null</p>
</blockquote>
</li>
</ul>
<p>#####函数的显示原型都继承 Object.prototype</p>
<blockquote>
<p>原型链的概念：</p>
</blockquote>
<p>一个对象继承的所有对象，被形象的称为对象的原型链<br>注释：原型链是一个描述对象继承结构，相对比较形象的词汇；</p>
<p>####继承的规律：</p>
<ol>
<li>谁的实例，这个实例就继承谁的prototype</li>
<li>所有对象继承的终点是Object.prototype</li>
<li>所有函数默认的显示原型 都继承 Object.prototype</li>
<li>所有的函数，都被看做是Function的实例，；所以都继承Function.prototype</li>
<li>所有的数组，都被看做是Array的实例，所以都继承Array.prototype</li>
<li>所有的正则，都被看做RexExp的实例，所以都继承Regexp.prototype.</li>
</ol>
<p>####对象的的类型</p>
<ul>
<li>在js中，函数比较特殊，他们都是Function类型的对象，但是可以配生出属于自己类型的对象</li>
<li>Date自身是Function类型，但是通过new Date创建出来的所有实例是Date类型</li>
<li>ECMAscript内置的—-函数类型的对象:<ul>
<li>String Number Boolean RegExp Function  Object Array Error Date </li>
</ul>
</li>
<li>上述九大构造函数的原型链结构:<ul>
<li>9大构造函数==&gt;Function.prototype==&gt;Object.prototype==&gt;null</li>
</ul>
</li>
<li>ECMAscript内置的——–非函数类型的对象；<ul>
<li>Math</li>
<li>Math原型链：Math==&gt;Object.prototype==&gt;null</li>
</ul>
</li>
</ul>
<p>####instanceof运算符</p>
<blockquote>
<p> 判断一个对象是不是另一个构造函数的实例。运算规则:判断左边对象的原型链结构中是否存在右边构造函数的显示原型<br>返回值：boolean</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line">        var xiaofang = new Person();</div><div class="line">        // xiaofang ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null</div><div class="line">        console.log( xiaofang instanceof Person );  // true</div><div class="line">        console.log( xiaofang instanceof Object );  // true</div><div class="line">         // 把Person.prototype进行覆写，覆写后xiaofang的原型链结构中，就不存在当前Person.prototype所指向的对象了。</div><div class="line">                Person.prototype = &#123;</div><div class="line">                    it: &apos;it&apos;</div><div class="line">                &#125;;</div><div class="line">                console.log( xiaofang instanceof Person );  // false</div><div class="line">                console.log( xiaofang.it );  // undefined</div><div class="line">                var xiaomei = new Person();</div><div class="line">                        console.log( xiaomei instanceof Person );  // true</div><div class="line">                        console.log( xiaomei.it );  // it</div></pre></td></tr></table></figure>
<ul>
<li>关于instanceof的例题</li>
</ul>
<blockquote>
<p>// Function ==&gt; // Function.prototype ==&gt; Object.prototype ==&gt; null<br>          // Object ==&gt; // Function.prototype ==&gt; Object.prototype ==&gt; null<br>          console.log(Function instanceof Object);  // true<br>          console.log(Function instanceof Function);  // true<br>          console.log(Object instanceof Object);  // true<br>          console.log(Object instanceof Function);  // true</p>
<p>####关于画图练习原型链</p>
<ol>
<li>关于原型覆写后的原型链</li>
</ol>
</blockquote>
<pre><code>function Person(){}
         function Student(){}
         Student.prototype = new Person();
         var jiajia = new Person();
         var meimei = new Student();
         // jijia 和 meimei 的原型链结构：
         // jiajia ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null
         // meimei ==&gt; Student.prototype（被覆写过的） ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null
</code></pre><hr>
<h2 id="gt-给Object-prototype扩展的属性与方法，所有的对象都可以使用"><a href="#gt-给Object-prototype扩展的属性与方法，所有的对象都可以使用" class="headerlink" title="&gt;  给Object.prototype扩展的属性与方法，所有的对象都可以使用"></a>&gt;  给Object.prototype扩展的属性与方法，所有的对象都可以使用</h2><p>####原型链结构</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="08精简版的原型链结构.png" alt="原型链结构"></h2><p><img src="04完整的原型链结构.png" alt="原型链结构"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/面向对象/">面向对象</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/hexo/">hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/14/面向对象/day01面向对象的基本概念及注意事项/" title="面向对象 第一天" itemprop="url">面向对象 第一天</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2015-01-14T12:37:51.000Z" itemprop="datePublished"> 发表于 2015-01-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><ul>
<li>关键字，通过他可以通过下标的方式获得所有的实参</li>
<li>length属性:用来获取实参的个数</li>
<li>arguments，是数组，</li>
<li>arguments 类似与这个样子：{  0: ‘实参1’, 1: ‘实参2’, length: 2 }</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">计算任意数据的和</div><div class="line">        function count( ) &#123;</div><div class="line">            var result = 0;</div><div class="line">            for ( var i = 0; i &lt; arguments.length; i++ ) &#123;</div><div class="line">                result += arguments[i];</div><div class="line">            &#125;</div><div class="line">            console.log(result);</div><div class="line">        &#125;</div><div class="line">        count(1,2,3,4,5,234,3467,4564,234)</div></pre></td></tr></table></figure>
<p>####伪数组</p>
<blockquote>
<p>拥有length属性，<br>以下标储存数据的对象</p>
</blockquote>
<p>####throw</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">写一个函数，函数接收一个参数并打印，如果参数的值是null或undefined，则报错。</div><div class="line">        function con( par ) &#123;</div><div class="line">            if ( par == null ) &#123;</div><div class="line">                throw &apos;参数错误！&apos; + par;</div><div class="line">            &#125;</div><div class="line">            console.log( par );</div><div class="line">        &#125;</div><div class="line">        //con(null);</div><div class="line">        //con(undefined);</div><div class="line">        con(111);</div><div class="line">        con(&apos;acb&apos;);</div></pre></td></tr></table></figure>
<p>####工厂模式</p>
<blockquote>
<p>该方法可以获取狗对象这种把创建对象封装起来的方式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function getDog(name, color) &#123;</div><div class="line">    var dog = new Object();</div><div class="line">    dog.name = name;</div><div class="line">    dog.color = color;</div><div class="line">    dog.say = function say() &#123;</div><div class="line">        console.log(&apos;旺旺&apos;);</div><div class="line">    &#125;;</div><div class="line">    return dog;</div><div class="line">&#125;</div><div class="line">var aLaSiJia = getDog(&apos;阿拉斯加&apos;, &apos;黑白相间&apos;);</div><div class="line">var jinMao = getDog(&apos;金毛&apos;, &apos;黄色&apos;);</div></pre></td></tr></table></figure>
<p>####构造函数</p>
<blockquote>
<p>构造函数只是函数的另外一个称呼，和普通函数无异；<br>如果一个普通函数，专门是用来配合new关键字创建对象的，<br>那么这个函数就可以称之为构造函数。<br>如果一个函数想当做构造函数使用，那么有一个潜规则就是函数名的首字母大写。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Dog(name, color) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.color = color;</div><div class="line">    this.say = function say() &#123;</div><div class="line">        console.log(&apos;旺旺&apos;);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul>
<li>就是对一些具有相同特征与特性的对象的抽象描述。</li>
<li>在ES6之前，可以把构造函数看作是类。</li>
</ul>
<h5 id="实例的类型"><a href="#实例的类型" class="headerlink" title="实例的类型"></a>实例的类型</h5><ul>
<li>实例的类型就是构造函数的名字。</li>
</ul>
<p>####工厂函数与构造函数的区别</p>
<blockquote>
<p>工厂函数与构造函数的区别：<br>工厂函数把通过构造函数创建对象的过程，进行了封装。<br>也就是说，工厂函数依赖构造函数。<br>工厂函数和构造函数起始都是普通函数，<br>只不过因为他们的作用不用，<br>从而产生了不用的称呼而已。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 构造函数，配合new关键字可以创建对象</div><div class="line">function Dog(name, color) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.color = color;</div><div class="line">    this.say = function say() &#123;</div><div class="line">        console.log(&apos;旺旺&apos;);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 工厂函数，就是把创建对象的过程进行了封装</div><div class="line">function getDog(name, color) &#123;</div><div class="line">    var dog = new Dog(name, color);</div><div class="line">    return dog;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####面向对象概念</p>
<blockquote>
<p>面向过程的概念：想到哪写哪，凡事亲力亲为，自己单干。面向对象的概念：利用对象解决问题，本质上就是对面向过程的封装。面向对象的好处是代码的重复利用，和函数很相似；面向对象可以认为是比函数封装更高一层的封装。<br>js对面向对象编程思想提供的支持：可以编写构造函数，然后利用构造函数构建出各种对象，利用这些对象帮我们解决问题。</p>
</blockquote>
<p>#####利用js创建一些人对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 构造函数，专门用来创建人对象</div><div class="line">        function Person(name, age, sex) &#123;</div><div class="line">            this.name = name;</div><div class="line">            this.age = age;</div><div class="line">            this.sex = sex;</div><div class="line">            this.eat = function () &#123;</div><div class="line">                console.log(&apos;必须吃！&apos;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 工厂函数，把创建人对象的过程进行了封装</div><div class="line">        function getPerson(name, age, sex) &#123;</div><div class="line">            return new Person(name, age, sex);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 创建一个谢娜对象</div><div class="line">        var xieNa = getPerson(&apos;谢娜&apos;, 18, &apos;女&apos;);</div><div class="line">        xieNa.eat();</div></pre></td></tr></table></figure>
<p>####类的概念</p>
<blockquote>
<p>类是对一些具有相同特征与特性对象的抽象描述   构造函数中，把某种具有相同特征与特性的对象进行了一个抽象描述,所以可以把js的构造函数看作是类(类可以认为是一个模子或者是模版,通过它可以创建出具有相同特征的对象)</p>
</blockquote>
<p>####实例</p>
<blockquote>
<p>通过构造函数创建出来的对象，就叫实例</p>
</blockquote>
<ul>
<li><p>实例和对象的关系</p>
<ul>
<li>没有可比行，都是对一个东西的称呼和描述，只不过角度不同罢了</li>
</ul>
</li>
</ul>
<p>####<strong>proto</strong></p>
<blockquote>
<ol>
<li>每一个对象都有一个<strong>proto</strong>属性。通过构造函数创建的实例对象，都会带有一个<strong>proto</strong>属性，这个属性的值与构造函数prototype属性的值一致，都存储着同一个对象的地址。</li>
<li><strong>proto</strong>相当是一个记录着宝藏存放的地址的属性；所有的对象都有这个属性，每当我们访问一个对象的属性或方法，那么首先会在自身去找，找不到就去顺着<strong>proto</strong>找宝藏，宝藏没有再继续顺序<strong>proto</strong>找下一个宝藏，直到终点。</li>
<li>Person.prototype里面存储的东西，就是为了让实例共享，得到节省内存的目的</li>
</ol>
</blockquote>
<p>####原型属性的称呼</p>
<blockquote>
<p>在js中，有两个属性都会指向原型对象，</p>
<ol>
<li>一个是prototype属性，我们称这个属性为显示原型(原型属性)；</li>
<li>一个是<strong>proto</strong>属性，我们称这个属性为隐式原型(原型对象)；</li>
</ol>
</blockquote>
<p>####对象的属性查找规则：</p>
<ol>
<li>每当我们访问一个对象的属性或方法时，</li>
<li>那么首先会在对象自身上找，</li>
<li>找不到就去顺着<strong>proto</strong>找，</li>
<li>没有再继续顺序<strong>proto</strong>找，</li>
<li>直到终点。</li>
</ol>
<p>####继承</p>
<ul>
<li>一个对象可以使用另一个对象的东西，就叫继承</li>
<li>一个对象可以使用本不属于自己的东西，就叫继承</li>
<li>继承的本质就是代码的复用,js中的原型就是对继承特性的实现</li>
<li>js中的原型就是为了让代码复用，所以原型就是js对继承这个特性的实现,一句话：在js中，原型就是继承</li>
<li>实例的<strong>proto</strong>属性，我们有时候会称它为实例的原型对象</li>
</ul>
<p>####继承方式</p>
<blockquote>
<p>下面记录的继承方式都是基于原型的，然后融入了一些程序猿自己的编程思想，从而引出了多种继承方式</p>
</blockquote>
<ul>
<li>默认的原型继承( 很常用 )</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;&#125;</div><div class="line">Fn.prototype.value=100;</div><div class="line">var fn=new Fn();</div></pre></td></tr></table></figure>
<ul>
<li>覆写构造函数的显式原型( 很常用 ) </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;&#125;</div><div class="line">Fn.prototype=&#123;</div><div class="line">    value:100;</div><div class="line">&#125;</div><div class="line">var fn=new Fn();</div></pre></td></tr></table></figure>
<ul>
<li>给显式原型混入属性( 很常用 ) </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function extend(o1,o2)&#123;</div><div class="line">    for(var key in  o2)&#123;</div><div class="line">        o1[key]=o2[key];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj=&#123;add:function(a,b)&#123;console.log(a+b)&#125;&#125;;</div><div class="line">function Fn()&#123;&#125;;</div><div class="line">extend(Fn.prototype,obj);</div><div class="line">extend(Fn.prototype,&#123;value:100&#125;)</div><div class="line">var fn=new Fn();</div></pre></td></tr></table></figure>
<ul>
<li>Object.create( 很少用 ) </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj= &#123;value:100&#125;;</div><div class="line">var newObj=Object.create(obj);</div></pre></td></tr></table></figure>
<ul>
<li>借用Object.create方法覆写显式原型( 很少用 )<br>语法：Object.create( 被继承的对象 );<br>返回值：返回一个新对象，新对象继承 传入 到create方法的对象。<br>作用是指定创建一个新对象，并且指定新对象的继承的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;value:100&#125;;</div><div class="line">function Fn()&#123;&#125;；</div><div class="line">Fn.prototype=Object.create(obj);</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<ul>
<li>复合式原型继承( 很少用 ) </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function PrFn()&#123;&#125;</div><div class="line">PrFn.prototype.value=100;</div><div class="line">function Fn()&#123;&#125;</div><div class="line">Fn.prototype=new PrFn();</div><div class="line">//实例继承Fn.prototype,Fn.prototype继承了PrFn.prototype,最终实例间接继承了PRFn.prototype</div><div class="line">var fn=new Fn();</div></pre></td></tr></table></figure>
<p>####注意事项</p>
<ul>
<li>构造函数有一个prototype属性，实例可以共享里面的东西，而构造函数自身无法访问里面的东西</li>
<li>构造函数添加的方法，只能自己调用</li>
<li>实例添加的方法只能自己调用</li>
<li>只有函数才拥有prototype属性，因为prototype属性的作用就是为了让实例共享，而只有函数才可以创造出实例，也就是说prototype只有放在函数上才会凸显出它的作用</li>
<li>任何对象都有<strong>proto</strong>属性</li>
<li>内置的属性不可枚举，无法用for in去遍历</li>
<li>Person的实例可以使用obj里面的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">可以考虑把obj对象里面的方法copy到Person的显式原型中，达到实例共享的目的，完成需求</div><div class="line">for ( var key in obj ) &#123;</div><div class="line">            Person.prototype[key] = obj[key];</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<ul>
<li>extend方法<blockquote>
<p>该方法会第二个对象的属性copy到第一个对象<br>  本质上是把多个对象的属性依次copy到原型对象中</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function extend(o1,o2)&#123;</div><div class="line">    for(var key in o2)&#123;</div><div class="line">        o1[key]=o2[key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####属性继承</p>
<blockquote>
<p>这种代码复用的方式：有地方叫它 对象冒充，也叫属性盗窃，也叫属性继承，最简单明了好理解的叫法是：构造函数借用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">需求：Person的实例可以使用Animal原型里面的方法</div><div class="line"> function Person(name, age, sex) &#123;</div><div class="line"> // 借用Animal函数，给Person实例添加属性</div><div class="line">  this.__Animal__ = Animal;</div><div class="line">  // 调用Animal函数时，里的this指向了当前Person的实例</div><div class="line">  this.__Animal__(name, age, sex);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>####静态成员与实例成员</p>
<blockquote>
<p>添加给实例的属性或者方法，就叫实例成员<br>添加给类自己的属性或者方法叫静态成员（类成员）</p>
<pre><code>- 类原型上的方法，本意也是给实例使用的，所以也可以认为是实例成员
</code></pre><pre><code>// 这是构造函数，也是类
       function Person(name, age) {
           // 这里的name和age属性，因为将来要添加到实例身上，
           // 所以也称之为实例成员(实例属性)
           this.name = name;
           this.age = age;
       }
</code></pre></blockquote>
<ul>
<li>直接添加到类上的属性或者方法叫静态成员或者类成员<ul>
<li>静态成员（类成员）只能由构造函数自己访问</li>
<li>构造函数内添加的实例成员，也只有实例可以访问<blockquote>
<p>Person.maxAge=200;</p>
</blockquote>
</li>
</ul>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/面向对象/">面向对象</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/hexo/">hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/14/面向对象/day 06/" title="面向对象第六天" itemprop="url">面向对象第六天</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2015-01-14T12:37:51.000Z" itemprop="datePublished"> 发表于 2015-01-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><blockquote>
<p>异步执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function callback() &#123;</div><div class="line">            console.log(111);</div><div class="line">        &#125;</div><div class="line">        // setTimeout是全局下的一个函数,</div><div class="line">        // 第一个参数要求是回调函数</div><div class="line">        // 传入setTimeout的回调函数，是异步执行的(即：不是随着代码的顺序执行)。</div><div class="line">        setTimeout(callback, 0);</div><div class="line">        console.log(222);</div><div class="line">        for ( var i = 0; i &lt; 10; i++ ) &#123;</div><div class="line">            console.log(i);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/面向对象/">面向对象</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/hexo/">hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/14/面向对象/复习javascript/" title="Javascript重点复习" itemprop="url">Javascript重点复习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2015-01-14T12:37:51.000Z" itemprop="datePublished"> 发表于 2015-01-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="javascript基础组成"><a href="#javascript基础组成" class="headerlink" title="javascript基础组成"></a>javascript基础组成</h2><ul>
<li>javascript由几部分组成？<blockquote>
<p>ECMAscript、DOM、BOM</p>
</blockquote>
</li>
</ul>
<p>##数据类型</p>
<p>####数据类型有哪些？</p>
<ul>
<li><p>基本数据类型<br>number、string、boolean、null、undefined</p>
</li>
<li><p>复杂数据类型<br>object</p>
</li>
</ul>
<p>####ECMAscript内置对象有哪些？</p>
<ul>
<li>Array、Math、Date、Object、String、Number、Boolean、Function、Error、RegExp</li>
</ul>
<p>####如何判断数据类型？</p>
<ul>
<li>typeof无法判断null类型的数据，反过来说typeof判断object类型的数据可能存在误判</li>
<li>typeof可以判断Function类型的对象</li>
</ul>
<p>##基本类型与引用类型的赋值问题</p>
<p>####基本类型</p>
<ul>
<li>赋的是具体的值</li>
</ul>
<p>####引用类型</p>
<ul>
<li>赋的是对象的地址</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>####算数运算符+%</p>
<ul>
<li>算数运算、字符串链接、把数据类型转化为number</li>
<li>取余数</li>
</ul>
<p>####逻辑运算符 &amp;&amp;　｜｜　！</p>
<ul>
<li>&amp;&amp;<br>从左往右依次把数据转化为boolean类型。如果为false则返回对应的数据，如果一直没有找到则返回最后一个值</li>
<li>||<br>从左到右依次把数据转化为boolean类型。如果为true则返回对应的值，如果一直没有找到，则返回最后一个值</li>
<li>！<br>把数据转化为boolean类型的值，然后取反</li>
</ul>
<p>####相等运算符　== === ！=  ！==</p>
<ul>
<li>===类型和值必须相等</li>
<li>== 会先进行数据的转化，然后进行比较（后面会提到）</li>
</ul>
<p>####三元运算符？：</p>
<ul>
<li>问号前面的表达式为true ，执行冒号前面的表达式，否则执行后面的表达式</li>
</ul>
<p>##布尔类型的转换</p>
<p>####如何把数据转化为布尔类型？</p>
<ul>
<li>！！Boolean</li>
</ul>
<p>####哪些数据类型在转化时数据类型为false</p>
<ul>
<li>0 、undefined、null、NaN、””</li>
<li>所有对象转化为boolean类型时都为true</li>
</ul>
<p>##语句</p>
<p>####分支语句</p>
<ul>
<li>if else  |switch case</li>
</ul>
<p>####循环语句</p>
<ul>
<li>for,while 、do while、for in </li>
</ul>
<p>####break 和continue作用是什么？</p>
<ul>
<li>break：结束循环</li>
<li>continue :结束当前循环，进入下一循环</li>
</ul>
<p>##函数</p>
<p>####创建方式</p>
<ul>
<li>函数声明式</li>
<li>函数表达式</li>
<li>Function</li>
</ul>
<p>####参数</p>
<ul>
<li>对函数中重复执行的代码中的不同部分的抽象提取</li>
<li>形参是用来接收实参传进来的值</li>
</ul>
<p>####返回值</p>
<ul>
<li>如果没有return 则返回undefined 如果有 则返回相对应的值</li>
</ul>
<p>####arguments</p>
<ul>
<li>一个代表实参的对象</li>
<li>可以通过下标的方式获取实参</li>
<li>可以通过length属性获取实参个数</li>
</ul>
<p>####this</p>
<ul>
<li>谁调用指向谁</li>
</ul>
<p>####错误抛出</p>
<ul>
<li>throw自定义错误抛出</li>
</ul>
<p>#+号</p>
<ul>
<li>如果两边含有字符串或者对象，那么转化为string后相加</li>
<li>除此外，两数相加，转化为number后相加</li>
</ul>
<p>#-号</p>
<ul>
<li>两数转化为number后相减</li>
</ul>
<p>#==运算符规则比较</p>
<blockquote>
<p>约定：空数据类型表示null和undefined两种数据类型</p>
</blockquote>
<ul>
<li>任何数据和NaN相比，结果都为false</li>
<li>null等于undefined</li>
<li>null和非空类型相比结果都为false</li>
<li>undefined和非空类型相比结果都为false</li>
<li>数字和非空类型相比，先转化为数字在相比</li>
<li>布尔和非空类型相比，先转化为数字在相比</li>
<li>对象与对象，直接比较地址</li>
<li>对象与字符串相比，先转化为字符串在进行比较</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>类型</th>
<th>规律</th>
</tr>
</thead>
<tbody>
<tr>
<td>NaN</td>
<td>任意类型</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>undefined</td>
<td>true</td>
</tr>
<tr>
<td>null</td>
<td>非空类型</td>
<td>false</td>
</tr>
<tr>
<td>数字</td>
<td>非空类型</td>
<td>转化为数字在比较</td>
</tr>
<tr>
<td>布尔</td>
<td>非空类型</td>
<td>转化为数字在进行比较</td>
</tr>
<tr>
<td>对象</td>
<td>对象</td>
<td>比较地址</td>
</tr>
<tr>
<td>对象</td>
<td>字符串</td>
<td>转化为字符串进行比较</td>
</tr>
</tbody>
</table>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/面向对象/">面向对象</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/hexo/">hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/14/面向对象/call apply/" title="面向对象  call、apply、bind" itemprop="url">面向对象  call、apply、bind</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2015-01-14T12:37:51.000Z" itemprop="datePublished"> 发表于 2015-01-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>这三个方法都是来自于Function.prototype上，所以所有的函数都可以使用。<br>他们有一个共同点，就是可以指定函数执行时内部this的指向。<br>call和apply的区别在于参数的方式。<br>bind和前两个方法的区别在于，bind不会马上执行函数，而是返回一个函数，供以后调用。</p>
</blockquote>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><blockquote>
<p>语法：函数名.call( this指向，实参1, 实参2…. )</p>
</blockquote>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><blockquote>
<p>语法1：函数名.apply( this指向，[实参1, 实参2….] )<br>语法2：函数名.apply( this指向，{0: 实参1, 1: 实参2, length: 2} )</p>
</blockquote>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><blockquote>
<p>语法：var fn = 函数名.bind( this指向，要绑定的实参1, 要绑定的实参2…. );</p>
</blockquote>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><blockquote>
<p>严格模式分为全局模式和局部模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 全局模式，就是在全局代码的最前面写上下面这句话</div><div class="line">&apos;use strict&apos;;</div></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 局部模式，就是在函数代码的最前面写上下面这句话</div><div class="line">function fn() &#123;</div><div class="line">    &apos;use strict&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>必须通过var定义变量</li>
<li>对象中不能存在重复的属性名</li>
<li>函数中不能存在重复的形参名</li>
<li>eval会产生单独的作用域，避免了全局变量的产生。</li>
<li>无法在非函数的代码块中声明函数了</li>
<li>禁止使用with语句</li>
<li>禁止使用函数的caller属性</li>
<li>禁止使用arguments的callee属性</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/面向对象/">面向对象</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/hexo/">hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/29/面向对象参考/面向对象第七天/" title="面向对象补充" itemprop="url">面向对象补充</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2014-10-29T09:06:32.000Z" itemprop="datePublished"> 发表于 2014-10-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><blockquote>
<p>Function.prototype自身是一个函数，并且这个函数是唯一没有prototype属性的函数</p>
</blockquote>
<ul>
<li>apply: 方法，可以改变函数执行时的内部指向</li>
<li>argments: 之前是函数的属性，现在这个属性被废弃了</li>
<li>bind: 方法，返回一个函数的copy版本，并且可以指定该函数执行时内部this的指向<ul>
<li>语法: 函数名.bind(指定返回函数执行时this指向，要绑定的实参1，要绑定的实参2…..);</li>
<li>返回值：函数的copy版本</li>
<li>ES5提供的方法</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//call和apply方法会马上执行函数</span></div><div class="line"><span class="comment">//bind不会马上执行，它返回函数的一个copy版本，供以后想执行的时候再执行</span></div><div class="line"><span class="keyword">var</span> length = <span class="number">666</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">length</span>: <span class="number">888</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.length + a + b);</div><div class="line">&#125;</div><div class="line">fn(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">fn.call(o, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">fn.call(o, <span class="number">2</span>, <span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> fnCopy = fn.bind();</div><div class="line">fnCopy(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">fnCopy(<span class="number">2</span>,<span class="number">2</span>);</div><div class="line">fnCopy(<span class="number">3</span>,<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(fnCopy === fn); <span class="comment">//打印false</span></div><div class="line"><span class="comment">/*--------------------------------*/</span></div><div class="line"><span class="keyword">var</span> baseNumber = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">baseNumber</span>: <span class="number">100</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.baseNumber + a + b + c)</div><div class="line">&#125;</div><div class="line"><span class="comment">//bind可以固定死形参内容</span></div><div class="line"><span class="keyword">var</span> fn = add.bind(o,<span class="number">10</span>,<span class="number">20</span>);</div><div class="line">fn(<span class="number">40</span>);</div><div class="line">fn(<span class="number">50</span>);</div></pre></td></tr></table></figure>
<ul>
<li>call: 方法，可以改变函数执行时的内部指向</li>
<li>caller: 返回调用该函数的函数</li>
<li>constructor: 对应的构造函数，即Function</li>
<li>length: 函数形参的个数</li>
<li>name: 函数的名字</li>
<li>toString: 把函数体作为字符串打印</li>
<li><code>__proto__</code>: Function.prototype所继承的对象，即Object.prototyope;</li>
</ul>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>严格模式分为两种:</p>
<ul>
<li><p>全局模式</p>
<blockquote>
<p>全局模式，即在代码的最前面添加一句<code>&#39;use strict&#39;</code>;</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line">a = <span class="number">1</span>; <span class="comment">//报错，在严格模式下，必须用过var来定义变量</span></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">a</span>:<span class="number">2</span>&#125;; <span class="comment">//报错，严格模式下，一个对象中不能存在重复的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,a</span>) </span>&#123;&#125; <span class="comment">// 报错，严格模式下，函数形参的名字不能重复</span></div><div class="line"><span class="built_in">eval</span>(<span class="string">'var ccc = 10'</span>); <span class="comment">// 使用严格模式，eval会产生单独的作用域，避免了全局变量的产生</span></div><div class="line"><span class="built_in">console</span>.log();</div><div class="line"><span class="comment">/*-------------------------------------*/</span></div><div class="line"><span class="comment">// 严格模式下，无法在非函数的代码块中声明函数了</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125; <span class="comment">// 报错 fn is no defind</span></div><div class="line"><span class="comment">/*--------------------------------------*/</span></div><div class="line"><span class="comment">//with语句使用</span></div><div class="line"><span class="comment">//在严格模式下禁止使用with语句</span></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">val</span>: <span class="number">100</span>,<span class="attr">name</span>: <span class="string">"zs"</span>&#125;;</div><div class="line"><span class="keyword">with</span>(obj) &#123;</div><div class="line">    <span class="built_in">console</span>.log(val);</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*-------------------------------------*/</span></div><div class="line"><span class="comment">//严格模式下，函数的caller属性禁止使用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(fn.caller)&#125;</div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;fn()&#125;());</div><div class="line"><span class="comment">//严格模式下，函数的callee属性禁止使用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(arhuments.callee)&#125;</div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;fn()&#125;());</div></pre></td></tr></table></figure>
</li>
<li><p>局部模式</p>
<blockquote>
<p>在函数的第一行添加<code>&#39;use strict&#39;</code></p>
</blockquote>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 只有fn函数内，才是严格模式</span></div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><ul>
<li>如果函数作为构造器使用，没有return语句，那么忽略，得到实例</li>
<li>如果函数作为构造器使用返回基本数据类型，就会被忽略</li>
<li>如果函数作为构造器使用，返回对象类型的数据，那么会覆盖掉实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="comment">//return 'abc'; //如果函数作为构造器使用返回基本数据类型，就会被忽略</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>; <span class="comment">//如果函数作为构造器使用，返回对象类型的数据，那么会覆盖掉实力</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fangfang = <span class="keyword">new</span> Person(<span class="string">'芳芳'</span>);</div><div class="line"><span class="built_in">console</span>.log(fangfang);</div></pre></td></tr></table></figure>
<h3 id="get和set"><a href="#get和set" class="headerlink" title="get和set"></a>get和set</h3><blockquote>
<p>setter、getter是ES5新增的一种语法，市面上称它们为读写器</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正常写法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</div><div class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            total++</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> total;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> counter = getCounter();</div><div class="line">counter.set();</div><div class="line">counter.get();</div><div class="line"><span class="comment">/*--------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        set setNum(par) &#123;</div><div class="line">            <span class="built_in">console</span>.log(par);</div><div class="line">            total++;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        get getNum() &#123;</div><div class="line">            <span class="keyword">return</span> total</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> counter = getCounter();</div><div class="line">counter.setNum = <span class="number">1</span>;</div><div class="line">counter.setNum = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(counter.getNum);</div><div class="line"></div><div class="line"><span class="comment">/*------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCache</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        set setCahe(val) &#123;</div><div class="line">            cache = val;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        get getCahe() &#123;</div><div class="line">            <span class="keyword">return</span> cache;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> cacheObj = getCache();</div><div class="line">cacheObj.setCahe = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(cacheObj.getCache);</div><div class="line"><span class="comment">/*-----------------------------------------*/</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    set val (par) &#123;</div><div class="line">        a = par;</div><div class="line">    &#125;,</div><div class="line">    get val () &#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//对于使用者来说，操作的是</span></div><div class="line">obj.val = <span class="number">10</span>;</div><div class="line">obj.val;</div></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归的特点:</p>
<ol>
<li>必须要有临界点(临界条件，return语句)</li>
<li>把要解决的问题就，尽量细化，如果发现解决问题时用到了之前的成果，并且是有规律的，</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*用递归的形式求阶乘</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> n*factorial( n - <span class="number">1</span> );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="comment">/*-------------------------------------------*/</span></div><div class="line"><span class="comment">//递归求阶乘添加缓存</span></div><div class="line"><span class="keyword">var</span> factorials = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> tempResult = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (factorials[n]) &#123;</div><div class="line">        <span class="keyword">return</span> factorials[n]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(n ===<span class="number">0</span>) &#123;</div><div class="line">        tempResult = <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        tempResult = factorial(n<span class="number">-1</span>) * n;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//先把结果缓存起来，然后再return出来</span></div><div class="line">    factorials[n] = tempResult;</div><div class="line">    <span class="keyword">return</span> tempResult;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">3</span>));</div></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/27/面向对象参考/继承方式/" title="继承" itemprop="url">继承</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2014-10-27T09:06:32.000Z" itemprop="datePublished"> 发表于 2014-10-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote>
<p>一个对象可以使用另一个对象的东西，就叫继承。<br>一个对象可以使用本不属于自己的东西，就叫继承。<br>js中的原型就是对继承特性的实现。</p>
</blockquote>
<h3 id="继承方式1-默认的原型继承-很常用"><a href="#继承方式1-默认的原型继承-很常用" class="headerlink" title="继承方式1 - 默认的原型继承( 很常用 )"></a>继承方式1 - 默认的原型继承( 很常用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Fn() &#123;&#125;</div><div class="line">Fn.prototype.value = 100;</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<h3 id="继承方式2-覆写构造函数的显式原型-很常用"><a href="#继承方式2-覆写构造函数的显式原型-很常用" class="headerlink" title="继承方式2 - 覆写构造函数的显式原型( 很常用 )"></a>继承方式2 - 覆写构造函数的显式原型( 很常用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Fn() &#123;&#125;</div><div class="line">Fn.prototype = &#123;</div><div class="line">     value: 100</div><div class="line"> &#125;</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<h3 id="继承方式3-给显式原型混入属性-很常用"><a href="#继承方式3-给显式原型混入属性-很常用" class="headerlink" title="继承方式3 - 给显式原型混入属性( 很常用 )"></a>继承方式3 - 给显式原型混入属性( 很常用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function extend(o1, o2) &#123;</div><div class="line">    for ( var key in o2 ) &#123;</div><div class="line">        o1[key] = o2[key];</div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line">var obj = &#123; add: function (a,b) &#123; console.log(a+b) &#125; &#125; </div><div class="line">function Fn() &#123;&#125;</div><div class="line">extend(Fn.prototype, obj);</div><div class="line">extend(Fn.prototype, &#123;</div><div class="line">    value: 100</div><div class="line">&#125;);</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<h3 id="继承方式4-Object-create-很少用"><a href="#继承方式4-Object-create-很少用" class="headerlink" title="继承方式4 - Object.create( 很少用 )"></a>继承方式4 - Object.create( 很少用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj = &#123; value: 100 &#125;</div><div class="line">var newObj = Object.create(obj);</div></pre></td></tr></table></figure>
<h3 id="继承方式5-借用Object-create方法覆写显式原型-很少用"><a href="#继承方式5-借用Object-create方法覆写显式原型-很少用" class="headerlink" title="继承方式5 - 借用Object.create方法覆写显式原型( 很少用 )"></a>继承方式5 - 借用Object.create方法覆写显式原型( 很少用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj = &#123; value: 100 &#125;</div><div class="line">function Fn() &#123;&#125;</div><div class="line">Fn.prototype = Object.create(obj);</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<h3 id="继承方式6-复合式原型继承-很少用"><a href="#继承方式6-复合式原型继承-很少用" class="headerlink" title="继承方式6 - 复合式原型继承( 很少用 )"></a>继承方式6 - 复合式原型继承( 很少用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function PrFn() &#123;&#125;</div><div class="line">PrFn.prototype.value = 100;</div><div class="line">function Fn() &#123;&#125;</div><div class="line">Fn.prototype = new PrFn()</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/26/面向对象参考/继承2/" title="继承" itemprop="url">继承</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Coldfont" target="_blank" itemprop="author">Coldfont</a>
		
  <p class="article-time">
    <time datetime="2014-10-26T09:06:32.000Z" itemprop="datePublished"> 发表于 2014-10-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="函数默认的prototype继承结构"><a href="#函数默认的prototype继承结构" class="headerlink" title="函数默认的prototype继承结构"></a>函数默认的prototype继承结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Person的显示原型对象所继承的对象为Object.prototype</p>
</blockquote>
<h2 id="字面量对象的继承结构"><a href="#字面量对象的继承结构" class="headerlink" title="字面量对象的继承结构"></a>字面量对象的继承结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="comment">/*</span></div><div class="line">*new Object 创建的实例，基础Object.prototype</div><div class="line">*和&#123;&#125;字面量对象一致；</div><div class="line">*其实&#123;&#125;就是new Object的简写形式</div><div class="line">*/</div></pre></td></tr></table></figure>
<blockquote>
<p>obj的继承结构</p>
<p>obj ==&gt; Object.protoyype ==&gt; null;</p>
</blockquote>
<p>数组的继承机构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [];</div></pre></td></tr></table></figure>
<blockquote>
<p>arr的继承结构</p>
<p>arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; null;</p>
</blockquote>
<h2 id="Math的继承结构"><a href="#Math的继承结构" class="headerlink" title="Math的继承结构"></a>Math的继承结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*Math.__proto__ ==&gt; Object.prototype</div><div class="line">*Math浏览器内部函数，直接继承子Object.prototype</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="继承的规律"><a href="#继承的规律" class="headerlink" title="继承的规律"></a>继承的规律</h2><ul>
<li>谁的实例就继承谁的.prototype</li>
<li>所有对象继承的终点是Object.prototype</li>
<li>所有函数默认的显示原型都继承Object.prototype</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/canvas/" title="canvas">canvas<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/面向对象/" title="面向对象">面向对象<sup>8</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/hexo/" title="hexo">hexo<sup>9</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Coldfont">Coldfont</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
